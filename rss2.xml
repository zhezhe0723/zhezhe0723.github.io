<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>可可托海</title>
    <link>http://zhezhe0723.github.io/</link>
    
    <atom:link href="http://zhezhe0723.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>尘埃落定之前，你我皆是黑马</description>
    <pubDate>Wed, 17 Aug 2022 17:27:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Array的常见用法</title>
      <link>http://zhezhe0723.github.io/2022/08/17/array-de-chang-jian-yong-fa/</link>
      <guid>http://zhezhe0723.github.io/2022/08/17/array-de-chang-jian-yong-fa/</guid>
      <pubDate>Wed, 17 Aug 2022 15:54:52 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;JS-中截取数组的方法&quot;&gt;&lt;a href=&quot;#JS-中截取数组的方法&quot; class=&quot;headerlink&quot; title=&quot;JS 中截取数组的方法&quot;&gt;&lt;/a&gt;JS 中截取数组的方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;splice()方法&lt;/strong&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="JS-中截取数组的方法"><a href="#JS-中截取数组的方法" class="headerlink" title="JS 中截取数组的方法"></a>JS 中截取数组的方法</h3><ol><li><strong>splice()方法</strong></li></ol><p>​         splice()方法通过删除或者替换现有元素或者原地添加新的元素来修改数组，并以数组的形式返回被修改的内容。这个方法会改变原数组。</p><p>​      <strong>–语法–</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">array<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>start<span class="token punctuation">[</span><span class="token punctuation">,</span>deleteCount<span class="token punctuation">[</span><span class="token punctuation">,</span>item1<span class="token punctuation">[</span><span class="token punctuation">,</span>item2<span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//start :指定修改的开始位置（从0开始计数），如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位（从后往前数）开始的第n 位；如果负数的绝对值大于数组的长度，则表示开始的位置为第0位。</span><span class="token comment">//deleteCount(可选) :整数，表示要删除的数组元素的个数。如果deleteCount大于start之后的元素的总数，则从start后面的元素都将被删除（包含第start位）；如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。</span><span class="token comment">// item1,item2(可选) :要添加进数组的元素，从start 位置开始。如果不指定，则 splice() 将只删除数组元素。</span><span class="token comment">// 返回值 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​     <strong>–案例–</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">,</span><span class="token string">"e"</span><span class="token punctuation">]</span><span class="token keyword">var</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"f"</span><span class="token punctuation">)</span> <span class="token comment">// 3 表示从索引为3的位置开始删除，</span><span class="token comment">// 1 删除元素的个数</span><span class="token comment">// 最后面是表示向原数组中添加元素，位置就是前面两个数字所定义的位置添加数据</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">//原数组：arr["a", "b", "c", "f", "e"]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span>  <span class="token comment">// 返回值 --被删除的元素 arr1 ["d"]</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">,</span><span class="token string">"e"</span><span class="token punctuation">]</span><span class="token keyword">var</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment">//原数组：arr ["a", "b", "e"]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span> <span class="token comment">// 返回值 --被删除的元素 arr1 ["c", "d"]</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">,</span><span class="token string">"e"</span><span class="token punctuation">]</span><span class="token keyword">var</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//从索引 1 的位置开始删除所有元素</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment">//原数组：arr["a"]   </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span> <span class="token comment">//返回值 --被删除的元素 arr1 ["b", "c", "d", "e"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content:encoded>
      
      
      <category domain="http://zhezhe0723.github.io/categories/Array/">Array</category>
      
      
      <category domain="http://zhezhe0723.github.io/tags/JS/">JS</category>
      
      
      <comments>http://zhezhe0723.github.io/2022/08/17/array-de-chang-jian-yong-fa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>uni-app使用总结</title>
      <link>http://zhezhe0723.github.io/2022/08/10/uni-app-shi-yong-zong-jie/</link>
      <guid>http://zhezhe0723.github.io/2022/08/10/uni-app-shi-yong-zong-jie/</guid>
      <pubDate>Tue, 09 Aug 2022 16:58:57 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;rich-text-富文本-图片自适应问题-解决&quot;&gt;&lt;a href=&quot;#rich-text-富文本-图片自适应问题-解决&quot; class=&quot;headerlink&quot; title=&quot;rich-text 富文本 图片自适应问题 解决&quot;&gt;&lt;/a&gt;rich-text 富文本 </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="rich-text-富文本-图片自适应问题-解决"><a href="#rich-text-富文本-图片自适应问题-解决" class="headerlink" title="rich-text 富文本 图片自适应问题 解决"></a>rich-text 富文本 图片自适应问题 解决</h3><p>  <strong>问题：</strong> rich-text是微信小程序的富文本标签，在使用rich-text的时候，需要rich-text内部图片宽高自适应。</p><p>  <strong>解决方法：</strong> 首先新建一个 text.js 文件</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * 处理富文本里的图片宽度自适应 * 1.去掉img标签里的style、width、height属性 * 2.img标签添加style属性：max-width:100%;height:auto * 3.修改所有style里的width属性为max-width:100% * 4.去掉&lt;br/>标签 * @param html * @returns &#123;void|string|*&#125; */</span><span class="token keyword">function</span> <span class="token function">formatRichText</span><span class="token punctuation">(</span><span class="token parameter">html</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> newContent<span class="token operator">=</span> html<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;img[^>]*></span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">match<span class="token punctuation">,</span>capture</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    match <span class="token operator">=</span> match<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">style="[^"]+"</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">style='[^']+'</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    match <span class="token operator">=</span> match<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">width="[^"]+"</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">width='[^']+'</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    match <span class="token operator">=</span> match<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">height="[^"]+"</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">height='[^']+'</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> match<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  newContent <span class="token operator">=</span> newContent<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">style="[^"]+"</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">match<span class="token punctuation">,</span>capture</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    match <span class="token operator">=</span> match<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">width:[^;]+;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span> <span class="token string">'max-width:100%;'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">width:[^;]+;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span> <span class="token string">'max-width:100%;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> match<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  newContent <span class="token operator">=</span> newContent<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;br[^>]*\/></span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  newContent <span class="token operator">=</span> newContent<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\&lt;img</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span> <span class="token string">'&lt;img style="max-width:100%;height:auto;display:block;margin-top:0;margin-bottom:0;"'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> newContent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  formatRichText<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   接下来，那个页面需要进行富文本展示，就把这个js 文件引入</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>formatRichText<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'xxxxx/text.js'</span>  <span class="token comment">//看自己的路径</span><span class="token comment">//这个是获取富文本的接口</span><span class="token function">teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>strings <span class="token operator">=</span> <span class="token function">formatRichText</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>teacherDetails<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//这是需要在页面上展示的内容</span><span class="token operator">&lt;</span>rich<span class="token operator">-</span>text <span class="token operator">:</span>nodes<span class="token operator">=</span><span class="token string">"strings"</span> style<span class="token operator">=</span><span class="token string">"width: 100%;"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>rich<span class="token operator">-</span>text<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>完美解决 uni-app 的 rich-text组件 中图片宽高自适应问题</strong> </p><p>加油加油加油！！！</p>]]></content:encoded>
      
      
      <category domain="http://zhezhe0723.github.io/categories/%E6%A1%86%E6%9E%B6/">框架</category>
      
      
      <category domain="http://zhezhe0723.github.io/tags/uni-app/">uni-app</category>
      
      
      <comments>http://zhezhe0723.github.io/2022/08/10/uni-app-shi-yong-zong-jie/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>商城项目问题汇总</title>
      <link>http://zhezhe0723.github.io/2022/08/01/shang-cheng-xiang-mu-wen-ti-hui-zong/</link>
      <guid>http://zhezhe0723.github.io/2022/08/01/shang-cheng-xiang-mu-wen-ti-hui-zong/</guid>
      <pubDate>Sun, 31 Jul 2022 16:52:12 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;在请求数据的时候后台报30001错&quot;&gt;&lt;a href=&quot;#在请求数据的时候后台报30001错&quot; class=&quot;headerlink&quot; title=&quot;在请求数据的时候后台报30001错&quot;&gt;&lt;/a&gt;在请求数据的时候后台报30001错&lt;/h3&gt;&lt;p&gt;  有一种可能是在数</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="在请求数据的时候后台报30001错"><a href="#在请求数据的时候后台报30001错" class="headerlink" title="在请求数据的时候后台报30001错"></a>在请求数据的时候后台报30001错</h3><p>  有一种可能是在数据请求的时候，请求头header 的格式不对,需要在请求的方法中写一个header 请求头</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getAddcart</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> req<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">url</span><span class="token operator">:</span><span class="token string">'/jingli-multishop/buyer/trade/carts'</span><span class="token punctuation">,</span><span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">'post'</span><span class="token punctuation">,</span>data<span class="token punctuation">,</span><span class="token literal-property property">header</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token string-property property">'content-type'</span><span class="token operator">:</span><span class="token string">'application/x-www-form-urlencoded'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content:encoded>
      
      
      <category domain="http://zhezhe0723.github.io/categories/%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98/">工作问题</category>
      
      
      <category domain="http://zhezhe0723.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">项目总结</category>
      
      
      <comments>http://zhezhe0723.github.io/2022/08/01/shang-cheng-xiang-mu-wen-ti-hui-zong/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Flex布局</title>
      <link>http://zhezhe0723.github.io/2022/07/10/flex-bu-ju/</link>
      <guid>http://zhezhe0723.github.io/2022/07/10/flex-bu-ju/</guid>
      <pubDate>Sun, 10 Jul 2022 14:59:14 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Flex-布局的定义&quot;&gt;&lt;a href=&quot;#Flex-布局的定义&quot; class=&quot;headerlink&quot; title=&quot;Flex 布局的定义&quot;&gt;&lt;/a&gt;Flex 布局的定义&lt;/h3&gt;&lt;p&gt;Flex 是Flexible Box 的缩写，意为“弹性布局” ，用来为盒状</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Flex-布局的定义"><a href="#Flex-布局的定义" class="headerlink" title="Flex 布局的定义"></a>Flex 布局的定义</h3><p>Flex 是Flexible Box 的缩写，意为“弹性布局” ，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为Flex 布局。 <code>.box&#123; display:flex;&#125;</code></p><p>行内元素也可以使用Flex 布局。 <code> .box &#123; display:inline-flex;&#125;</code></p><blockquote><p>Webkit 内核的浏览器，必须加上 <strong>-webkit</strong>  前缀 <code> .box &#123;display: -webkit-flex; display:flex;&#125;</code></p><p>在设置了Flex 布局之后，子元素中的  float, clear, vertical-align 属性将失效</p></blockquote><h3 id="Flex-的基本概念"><a href="#Flex-的基本概念" class="headerlink" title="Flex 的基本概念"></a>Flex 的基本概念</h3><p>  在采用了Flex 布局的元素，称为 Flex 容器 （flex container），简称“ 容器”。 它的所有子元素自动成为容器成员，称为 Flex 项目（ flex item）,简称“项目”。</p><p>容器默认存在两根轴： 水平的主轴（main axis） 和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start, 结束位置 叫做 main end; 交叉轴的开始位置叫做 cross start,结束位置叫做 cross end。</p><blockquote><p>项目默认沿主轴排列，单个项目占据的主轴空间叫做 main size,占据的交叉轴空间 叫做 cross size</p></blockquote><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><ul><li>flex-direction   决定主轴的方向，即项目的排列方向</li><li>flex-wrap  换行方式</li><li>flex-flow   上边两个属性的简写形式</li><li>justify-content   主轴上的对齐方式</li><li>align-items   交叉轴上的对齐方式</li><li>align-content    多根轴线的对齐方式</li></ul><h4 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h4><p>flex-direction 属性决定主轴的方向，（即项目的排列方向）</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">&#123;</span>  <span class="token property">flex-direction</span><span class="token punctuation">:</span>row<span class="token punctuation">;</span>   //主轴为水平方向，起点在左端  <span class="token property">flex-direction</span><span class="token punctuation">:</span>row-reverse<span class="token punctuation">;</span>  //起点在右端  <span class="token property">flex-direction</span><span class="token punctuation">:</span>column<span class="token punctuation">;</span>  //主轴为垂直方向，起点在上方  <span class="token property">flex-direction</span><span class="token punctuation">:</span>column-reverse<span class="token punctuation">;</span>  //起点在下方<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h4><p> flex-wrap 属性，在默认情况下，项目都排在一条线（轴线）上，flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">&#123;</span>  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span>  //默认，不换行  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap<span class="token punctuation">;</span>  //换行，第一行在上方或左方（根据主轴方向）  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap-reverse<span class="token punctuation">;</span>  //换行，第一行在下方或右方（根据主轴方向）<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="flex-flow-属性"><a href="#flex-flow-属性" class="headerlink" title="flex-flow 属性"></a>flex-flow 属性</h4><p>  flex-flow 属性是 flex-direction 和 flex-wrap 的简写形式，默认值为 ** row  nowrap**。</p><h4 id="justify-content-属性"><a href="#justify-content-属性" class="headerlink" title="justify-content 属性"></a>justify-content 属性</h4><p>  justify-content 属性定义了项目在主轴上的对齐方式。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">&#123;</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start<span class="token punctuation">;</span>  // 默认值 左对齐  <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span>  // 右对齐  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  //居中  <span class="token property">justify-content</span><span class="token punctuation">:</span> space-between<span class="token punctuation">;</span>  //两端对齐，项目之间的间隔都相等  <span class="token property">justify-content</span><span class="token punctuation">:</span> space-around<span class="token punctuation">;</span>  //每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="align-items-属性"><a href="#align-items-属性" class="headerlink" title="align-items 属性"></a>align-items 属性</h4><p>  align-items 属性定义项目在交叉轴上如何对齐。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">&#123;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> flex-start<span class="token punctuation">;</span>  // 交叉轴的起点对齐  <span class="token property">align-items</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span>  //交叉轴的终点对齐  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  //交叉轴的中点对齐  <span class="token property">align-items</span><span class="token punctuation">:</span> baseline<span class="token punctuation">;</span>  //项目的第一行文字的基线对齐  <span class="token property">align-items</span><span class="token punctuation">:</span> stretch<span class="token punctuation">;</span>  //如果项目未设置高度或设为auto<span class="token punctuation">,</span>将占满整个容器的高度<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="align-content-属性"><a href="#align-content-属性" class="headerlink" title="align-content 属性"></a>align-content 属性</h4><p> align-content 属性定义了多根轴线的对齐方式，如果项目只有一根轴线，则该属性不起作用。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">&#123;</span>  <span class="token property">align-content</span><span class="token punctuation">:</span> flex-start<span class="token punctuation">;</span>  //与交叉轴的起点对齐  <span class="token property">align-content</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span>  //与交叉轴的终点对齐  <span class="token property">align-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  //与交叉轴的中点对齐  <span class="token property">align-content</span><span class="token punctuation">:</span> space-between<span class="token punctuation">;</span>  //与交叉轴两端对齐，轴线之间的间隔平均分布  <span class="token property">align-content</span><span class="token punctuation">:</span> sapce-around<span class="token punctuation">;</span>  //每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。  <span class="token property">align-content</span><span class="token punctuation">:</span> stretch<span class="token punctuation">;</span>  //默认值，轴线占满整个交叉轴<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul><li>order   项目的排列顺序</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><h4 id="order-属性"><a href="#order-属性" class="headerlink" title="order 属性"></a>order 属性</h4><p>  order 属性定义项目的排列顺序，数值越小，排列越靠前，默认为 0 。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.item</span> <span class="token punctuation">&#123;</span>  <span class="token property">order</span><span class="token punctuation">:</span> &lt;<span class="token function">integer</span><span class="token punctuation">(</span>整数<span class="token punctuation">)</span>><span class="token punctuation">;</span>  //<span class="token property">order</span><span class="token punctuation">:</span> 2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="flex-grow-属性"><a href="#flex-grow-属性" class="headerlink" title="flex-grow 属性"></a>flex-grow 属性</h4><p>  flex-grow 属性定义项目的放大比例，默认为 0 ，即如果存在剩余空间，也不放大。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.item</span> <span class="token punctuation">&#123;</span>  <span class="token property">flex-grow</span><span class="token punctuation">:</span> &lt;number><span class="token punctuation">;</span>  //default 0 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p></blockquote><h4 id="flex-shrink-属性"><a href="#flex-shrink-属性" class="headerlink" title="flex-shrink 属性"></a>flex-shrink 属性</h4><p>  flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.item</span> <span class="token punctuation">&#123;</span>  <span class="token property">flex-shrink</span><span class="token punctuation">:</span> &lt;number><span class="token punctuation">;</span> //default 1<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p></blockquote><h4 id="flex-basis-属性"><a href="#flex-basis-属性" class="headerlink" title="flex-basis 属性"></a>flex-basis 属性</h4><p>   <code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.item</span> <span class="token punctuation">&#123;</span>  <span class="token property">flex-basis</span><span class="token punctuation">:</span> &lt;length>  //default auto<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p></blockquote><h4 id="flex-属性"><a href="#flex-属性" class="headerlink" title="flex 属性"></a>flex 属性</h4><p>  <code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.item</span> <span class="token punctuation">&#123;</span>  <span class="token property">flex</span><span class="token punctuation">:</span> none | [ &lt;<span class="token string">'flex-grow'</span>> &lt;<span class="token string">'flex-shrink'</span>>? || &lt;<span class="token string">'flex-basis'</span>> ]<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></blockquote><h4 id="align-self-属性"><a href="#align-self-属性" class="headerlink" title="align-self 属性"></a>align-self 属性</h4><p>  <code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.item</span> <span class="token punctuation">&#123;</span>  <span class="token property">align-self</span><span class="token punctuation">:</span> auto | flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://zhezhe0723.github.io/categories/%E5%B8%83%E5%B1%80/">布局</category>
      
      
      <category domain="http://zhezhe0723.github.io/tags/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">使用手册</category>
      
      
      <comments>http://zhezhe0723.github.io/2022/07/10/flex-bu-ju/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vuex</title>
      <link>http://zhezhe0723.github.io/2022/07/02/vuex/</link>
      <guid>http://zhezhe0723.github.io/2022/07/02/vuex/</guid>
      <pubDate>Sat, 02 Jul 2022 04:24:12 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;介绍Vuex&quot;&gt;&lt;a href=&quot;#介绍Vuex&quot; class=&quot;headerlink&quot; title=&quot;介绍Vuex&quot;&gt;&lt;/a&gt;介绍Vuex&lt;/h3&gt;&lt;p&gt;Vuex 是一个专为 Vue.js 应用程序开发的&lt;strong&gt;状态管理模式 + 库&lt;/strong&gt;。它</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="介绍Vuex"><a href="#介绍Vuex" class="headerlink" title="介绍Vuex"></a>介绍Vuex</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式 + 库</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><blockquote><p>vuex 的工作流程：用户组件按钮 →通过dispatch去触发→actions→通过commit（提交）触发→mutation→进而改变→state→伴随着state的改变，重新渲染组件。actions是异步；mutation是同步；往往用户在调后端接口请求数据是异步操作，所以需要借助actions</p></blockquote><p><strong>什么样的数据适合存储到Vuex中：</strong>一般情况下，只有组件之间共享的数据，才有必要存储到vuex中；对于组件中的私有数据，依旧存储在组件自身的data中即可。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>State提供唯一的公共数据源，所有共享的数据都要统一放到 Store的 State 中进行存储。</p><p><strong>方法</strong>:</p><ol><li>通过this.$store.state.全局数据名称 访问 由于在模板字符串中，是不需要写this的，所以直接写this后边的。  <code>展示count 的值&#123;&#123;$store.state.count&#125;&#125;</code></li><li>mapState 映射为计算属性：通过刚才导入的mapState函数，将当前组件需要的全局数据，映射为当前组件的computed 计算属性</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 使用： <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>h3<span class="token operator">></span>当前最新的count值为：<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> xCount <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span><span class="token comment">//1.导入辅助函数 mapState</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> mapState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// mapState 可以接收数组或对象形式的参数 映射为计算属性，下面分别示例</span>    <span class="token comment">//2.1 传入数组 </span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'count'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">//2.2 对象形式 可以自定义名称</span><span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token function-variable function">xCount</span><span class="token operator">:</span><span class="token parameter">state</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>count<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h4><p>Getter 用于对 Store中的数据进行加工处理形成新的数据。Getter <strong>不会修改 Store 中的原数据</strong>，它只起到一个包装器的作用，将Store中的数据加工后输出出来。</p><ol><li>Getter可以对 Store中已有的数据加工处理之后形成新的数据，类似Vue的计算属性。</li><li>Store中数据发生变化， Getter 的数据也会跟着变化。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//定义 Getter</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">state</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token literal-property property">count</span><span class="token operator">:</span><span class="token number">0</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">showNum</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token string">'当前最新的数量是【'</span> <span class="token operator">+</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token string">'】'</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法：</strong></p><ol><li><p>通过this.$store.getters.名称 访问 <code>this.$store.getters.名称</code></p></li><li><p>mapGetters映射为计算属性 </p>   <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> mapGetters <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token literal-property property">computed</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'showNum'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的**事件类型 (type)**和一个**回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数</p><p>mutation用于变更State中的数据，只有mutation里的函数，才有权力修改state的数据；mutation是同步操作</p><p>①只能通过 mutations变更 Store数据，不可以直接操作 Store中的数据。<br>②通过这种方式虽然操作起来稍微繁琐一些，但是可以集中监控所有数据的变化</p><p><strong>方法：</strong></p><ol><li>this.$store.commit() 触发mutations</li><li>通过刚才按需导入的mapMutation函数，映射为当前组件的methods函数。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// store</span><span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 变更状态</span>    state<span class="token punctuation">.</span>count<span class="token operator">++</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">sub</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    state<span class="token punctuation">.</span>count<span class="token operator">--</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">addN</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> step</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 变更状态</span>    state<span class="token punctuation">.</span>count <span class="token operator">+=</span> step  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">subN</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> step</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    state<span class="token punctuation">.</span>count <span class="token operator">-=</span> step  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">// 组件A</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> mapState<span class="token punctuation">,</span>mapMutations <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>  <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'sub'</span><span class="token punctuation">,</span><span class="token string">'subN'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 调用 </span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">decrementN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">subN</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Actions-专门处理异步操作"><a href="#Actions-专门处理异步操作" class="headerlink" title="Actions 专门处理异步操作"></a>Actions 专门处理异步操作</h4><p>Actions用于处理异步任务；如果通过异步操作变更数据，必须通过 Action,而不能使用Mutation,但是在 Action中还是要通过触发Mutation的方式间接变更数据。</p><blockquote><p> 注意： 在Actions 中不能直接修改 state中的数据，要通过 mutations修改。</p></blockquote><p><strong>方法：</strong></p><ol><li>this.$store.dispath 触发Actions</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义 Action</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>store</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token comment">// ...省略其他代码</span>  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 只有 mutations中的函数才有权利修改 state。</span>    <span class="token comment">// 不能在 mutations里执行异步操作。</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      state<span class="token punctuation">.</span>count<span class="token operator">++</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 在Actions 中不能直接修改 state中的数据，要通过 mutations修改。</span>    <span class="token function">addAsync</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'add'</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//组件A</span><span class="token comment">// 触发 Action</span><span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>  <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 触发 actions 的第一种方式</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'addAsync'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>mapActions 映射为方法</li></ol><ul><li><p>从Vuex中按需导入 mapActions 函数  <code>import &#123;mapActions&#125; from &#39;vuex&#39;</code></p></li><li><p>将指定的 actions 函数，映射为当前组件 methods 的方法。 </p> <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>  <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'subAsync'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">decrementAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">subAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> moduleB <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">modules</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">a</span><span class="token operator">:</span> moduleA<span class="token punctuation">,</span>    <span class="token literal-property property">b</span><span class="token operator">:</span> moduleB  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>a <span class="token comment">// -> moduleA 的状态</span>store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>b <span class="token comment">// -> moduleB 的状态</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Module 详情参照<a href="https://vuex.vuejs.org/zh/guide/modules.html#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B1%80%E9%83%A8%E7%8A%B6%E6%80%81">官方文档</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="http://zhezhe0723.github.io/categories/Vuex/">Vuex</category>
      
      
      <category domain="http://zhezhe0723.github.io/tags/Vue/">Vue</category>
      
      
      <comments>http://zhezhe0723.github.io/2022/07/02/vuex/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>前端工程化与webpack</title>
      <link>http://zhezhe0723.github.io/2022/06/01/qian-duan-gong-cheng-hua-yu-webpack/</link>
      <guid>http://zhezhe0723.github.io/2022/06/01/qian-duan-gong-cheng-hua-yu-webpack/</guid>
      <pubDate>Wed, 01 Jun 2022 11:14:22 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前端工程化&quot;&gt;&lt;a href=&quot;#前端工程化&quot; class=&quot;headerlink&quot; title=&quot;前端工程化&quot;&gt;&lt;/a&gt;前端工程化&lt;/h2&gt;&lt;p&gt;  在企业级的前端项目开发中，把前端开发所需的工具，技术，流程，经验等进行规范化，标准化。实际就是实现前端的四个现代</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p>  在企业级的前端项目开发中，把前端开发所需的工具，技术，流程，经验等进行规范化，标准化。实际就是实现前端的四个现代化：模块化；组件化；规范化；自动化。<br>它的好处主要体现在：</p><ol><li>前端工程化让前端开发能够“自成体系”，覆盖了前端项目从创建到部署的方方面面</li><li>最大程度地提高了前端的开发效率，降低了技术选型、前后端联调等带来的协调沟通成本<br>目前主流的前端工程化解决方案：</li></ol><ul><li>webpack <a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a> 常用</li><li>parcel <a href="https://zh.parceljs.org/">https://zh.parceljs.org/</a></li></ul><h2 id="webpack-的基本使用"><a href="#webpack-的基本使用" class="headerlink" title="webpack 的基本使用"></a>webpack 的基本使用</h2><h3 id="在项目中安装-webpack"><a href="#在项目中安装-webpack" class="headerlink" title="在项目中安装 webpack"></a>在项目中安装 webpack</h3><p>在终端运行如下的命令，安装webpack 相关的两个包<code>npm i webpack@5.5.1 webpack-cli@4.2.0 -D</code></p><h3 id="在项目中配置webpack"><a href="#在项目中配置webpack" class="headerlink" title="在项目中配置webpack"></a>在项目中配置webpack</h3><p>① 在项目根目录中，创建名为 webpack.config.js 的 webpack 配置文件，并初始化如下的基本配置：</p><pre class="line-numbers language-none"><code class="language-none">module.exports &#x3D; &#123;  mode: &#39;development&#39;, &#x2F;&#x2F; 开发环境：development 不会对打包生成的文件进行代码压缩和性能优化,打包速度快，适合在开发阶段使用&#x2F;&#x2F; 生产环境：production 会对打包生成的文件进行代码压缩和性能优化，打包速度很慢，仅适合在项目发布阶段使用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>② 在 package.json 的 scripts 节点下，新增 dev 脚本如下：</p><pre class="line-numbers language-none"><code class="language-none">&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;webpack&quot;, &#x2F;&#x2F;通过 npm run dev 来执行  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>③ 在终端中运行 npm run dev 命令，启动 webpack 进行项目的打包构建</p><p><strong>webpack.config.js 文件的作用：</strong>webpack.config.js 是 webpack 的配置文件。webpack 在真正开始打包构建之前，会先读取这个配置文件，从而基于给定的配置，对项目进行打包。<br>注意：由于 webpack 是基于 node.js 开发出来的打包工具，因此在它的配置文件中，支持使用 node.js 相关<br>的语法和模块进行 webpack 的个性化配置。</p><p><strong>自定义打包的入口与出口：</strong>在 webpack.config.js 配置文件中，通过 entry 节点指定打包的入口。通过 output 节点指定打包的出口。示例代码如下：</p><pre class="line-numbers language-none"><code class="language-none">const path &#x3D; require(&#39;path&#39;)module.exports&#x3D;&#123;  entry: path.join(__dirname, &#39;.&#x2F;src&#x2F;index.js&#39;),&#x2F;&#x2F;入口文件的路径  &#x2F;&#x2F; 指定打包的出口  output: &#123;    &#x2F;&#x2F; 表示输出文件的存放路径    path: path.join(__dirname, &#39;.&#x2F;dist&#39;),    &#x2F;&#x2F; 表示输出文件的名称,路径加js为了发布之后文件分类明确    filename: &#39;js&#x2F;bundle.js&#39;,  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="webpack-中的插件"><a href="#webpack-中的插件" class="headerlink" title="webpack 中的插件"></a>webpack 中的插件</h3><p><strong>webpack-dev-server：</strong>可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。<br>安装：<code>npm i webpack-dev-server@3.11.0 -D</code><br>配置：① 修改 package.json -&gt; scripts 中的 dev 命令如下：</p><pre class="line-numbers language-none"><code class="language-none">&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;webpack,serve&quot;, &#x2F;&#x2F;通过 npm run dev 来执行  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>② 再次运行 npm run dev 命令，重新进行项目的打包<br>③ 在浏览器中访问 <a href="http://localhost:8080/">http://localhost:8080</a> 地址，查看自动打包效果</p><blockquote><p>注意：webpack-dev-server 会启动一个实时打包的 http 服务器,配置了 webpack-dev-server 之后，打包生成的文件存放到了内存中,提高了实时打包输出的性能，因为内存比物理磁盘速度快很多。<br>生成到内存中的文件该如何访问？webpack-dev-server 生成到内存中的文件，默认放到了项目的根目录中，而且是虚拟的、不可见的。可以直接用 &#x2F; 表示项目根目录，后面跟上要访问的文件名称，即可访问内存中的文件。<br>例如 &#x2F;bundle.js 就表示要访问 webpack-dev-server 生成到内存中的 bundle.js 文件</p></blockquote><p>**html-webpack-plugin:**是 webpack 中的 HTML 插件，可以通过此插件自定制 index.html 页面的内容。<br>需求：通过 html-webpack-plugin 插件，将 src 目录下的 index.html 首页，复制到项目根目录中一份.<br>安装：<code>npm i html-webpack-plugin@4.5.0 -D</code><br>配置：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 1. 导入插件，得到构造函数const HtmlPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)&#x2F;&#x2F; 2. 创建插件的实例对象const htmlPlugin &#x3D; new HtmlPlugin(&#123;  template: &#39;.&#x2F;src&#x2F;index.html&#39;,  filename: &#39;.&#x2F;index.html&#39;,&#125;)module.exports&#x3D;&#123;    modu:&#39;development&#39;,    plugins:[htmlPlugin], &#x2F;&#x2F; 3. 挂载插件的实例对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>解惑 html-webpack-plugin,① 通过 HTML 插件复制到项目根目录中的 index.html 页面，也被放到了内存中<br>② HTML 插件在生成的 index.html 页面的底部，自动注入了打包的 bundle.js 文件</p></blockquote><p>**devServer 节点:**在 webpack.config.js 配置文件中，可以通过 devServer 节点对 webpack-dev-server 插件进行更多的配置，示例代码如下：</p><pre class="line-numbers language-none"><code class="language-none">devServer: &#123;  open: true,  host: &#39;127.0.0.1&#39;,  port: 80,&#125;,&#x2F;&#x2F;只要修改配置文件，就要重新启动服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="webpack-中的loader"><a href="#webpack-中的loader" class="headerlink" title="webpack 中的loader"></a>webpack 中的loader</h3><p>在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块，<br>webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！<br>loader 加载器的作用：协助 webpack 打包处理特定的文件模块。比如：</p><ul><li>css-loader 可以打包处理 .css 相关的文件</li><li>less-loader 可以打包处理 .less 相关的文件</li><li>babel-loader 可以打包处理 webpack 无法处理的高级 JS 语法</li></ul><p><strong>打包处理css 文件</strong><br>① 运行 <code>npm i style-loader@2.0.0 css-loader@5.0.1 -D</code> 命令，安装处理 css 文件的 loader<br>② 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下：</p><pre class="line-numbers language-none"><code class="language-none">module: &#123;    rules: [      &#x2F;&#x2F; test 表示匹配的文件类型， use 表示对应要调用的 loader      &#x2F;&#x2F;  use 数组中指定的 loader 顺序是固定的;多个 loader 的调用顺序是：从后往前调用      &#123; test: &#x2F;\.css$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] &#125;,    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>打包处理 less 文件</strong><br>① 运行 <code>npm i less-loader@7.1.0 less@3.12.2 -D </code>命令<br>② 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下：</p><pre class="line-numbers language-none"><code class="language-none">module: &#123;    rules: [      &#x2F;&#x2F; test 表示匹配的文件类型， use 表示对应要调用的 loader      &#x2F;&#x2F;  use 数组中指定的 loader 顺序是固定的;多个 loader 的调用顺序是：从后往前调用      &#123; test: &#x2F;\.less$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] &#125;,    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>打包处理样式表中与 url 路径相关的文件</strong><br>① 运行 <code>npm i url-loader@4.1.1 file-loader@6.2.0 -D</code> 命令<br>② 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下：</p><pre class="line-numbers language-none"><code class="language-none">module: &#123;    rules: [     &#123;        test: &#x2F;\.jpg|png|gif$&#x2F;,        use: &#123;          loader: &#39;url-loader&#39;,          options: &#123;            limit: 22228,&#x2F;&#x2F; limit 用来指定图片的大小，单位是字节（byte）只有 ≤ limit 大小的图片，才会被转为 base64 格式的图片            outputPath: &#39;image&#39;,            &#125;,        &#125;,      &#125;,    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>打包处理js 文件中的高级语法</strong><br>webpack 只能打包处理一部分高级的 JavaScript 语法。对于那些 webpack 无法处理的高级 js 语法，需要借<br>助于 babel-loader 进行打包处理。例如 webpack 无法处理下面的 JavaScript 代码：<br>安装 babel-loader 相关的包：<code>npm i babel-loader@8.2.1 @babel/core@7.12.3 @babel/plugin-proposal-class-properties@7.12.1 -D</code><br>配置：在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  test: &#x2F;\.js$&#x2F;,  exclude: &#x2F;node_modules&#x2F;,  &#x2F;&#x2F; exclude 为排除项，不需要处理标注的文件  use: &#123;    loader: &#39;babel-loader&#39;,    options: &#123;      plugins: [&#39;@babel&#x2F;plugin-proposal-class-properties&#39;],    &#125;,  &#125;,&#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>打包发布</strong><br>项目开发完成之后，使用 webpack 对项目进行打包发布的主要原因有以下两点：<br>① 开发环境下，打包生成的文件存放于内存中，无法获取到最终打包生成的文件<br>② 开发环境下，打包生成的文件不会进行代码压缩和性能优化<br>为了让项目能够在生产环境中高性能的运行，因此需要对项目进行打包发布<br>配置webpack 的打包发布：在 package.json 文件的 scripts 节点下，新增 build 命令如下：</p><pre class="line-numbers language-none"><code class="language-none">&quot;scripts&quot;: &#123;  &quot;dev&quot;: &quot;webpack serve&quot;,  &#x2F;&#x2F; --model 是一个参数项，用来指定 webpack 的运行模式。production 代表生产环境，会对打包生成的文件进行代码压缩和性能优化。通过 --model 指定的参数项，会覆盖 webpack.config.js 中的 model 选项。  &quot;build&quot;: &quot;webpack --mode production&quot;&#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>③ 把 JavaScript 文件统一生成到 js 目录中<br>④ 把图片文件统一生成到 image 目录中<br>⑤ 自动清理 dist 目录下的旧文件：为了在每次打包发布时自动清理掉 dist 目录中的旧文件，可以安装并配置 clean-webpack-plugin 插件：<code>npm i clean-webpack-plugin@3.0.0 -D</code></p><pre class="line-numbers language-none"><code class="language-none">const &#123; CleanWebpackPlugin &#125; &#x3D; require(&#39;clean-webpack-plugin&#39;)const cleanPlugin &#x3D; new CleanWebpackPlugin()plugins: [htmlPlugin, cleanPlugin], <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h3><p>Source Map 就是一个信息文件，里面储存着位置信息。也就是说，Source Map 文件中存储着代码压缩混淆前后的对应关系。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码，能够极大的方便后期的调试。<br>**默认 Source Map 的问题:**开发环境下默认生成的 Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题。<br>**解决默认 Source Map 的问题:**开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数保持一致</p><pre class="line-numbers language-none"><code class="language-none">module.exports&#x3D;&#123;  &#x2F;&#x2F; eval-source-map 仅限在开发模式下使用  &#x2F;&#x2F; devtool: &#39;eval-source-map&#39;,  &#x2F;&#x2F; 生产环境下，建议关闭 SourceMap 或将 devtool 的值设置为 nosources-source-map  &#x2F;&#x2F; devtool: &#39;nosources-source-map&#39;,只想定位报错的具体行数，且不想暴露源码  &#x2F;&#x2F; devtool: &#39;source-map&#39;,想在定位报错行数的同时，展示具体报错的源码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Source Map 的最佳实践:</strong><br>① 开发环境下：</p><ul><li>建议把 devtool 的值设置为 eval-source-map</li><li>好处：可以精准定位到具体的错误行<br>② 生产环境下：</li><li>建议关闭 Source Map 或将 devtool 的值设置为 nosources-source-map</li><li>好处：防止源码泄露，提高网站的安全性</li></ul>]]></content:encoded>
      
      
      <category domain="http://zhezhe0723.github.io/categories/%E5%B7%A5%E5%85%B7/">工具</category>
      
      
      <category domain="http://zhezhe0723.github.io/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/">打包构建</category>
      
      
      <comments>http://zhezhe0723.github.io/2022/06/01/qian-duan-gong-cheng-hua-yu-webpack/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Vue基础入门(二)</title>
      <link>http://zhezhe0723.github.io/2022/04/05/vue-ji-chu-ru-men-er/</link>
      <guid>http://zhezhe0723.github.io/2022/04/05/vue-ji-chu-ru-men-er/</guid>
      <pubDate>Tue, 05 Apr 2022 14:56:02 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;重点知识：&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vue中常用的生命周期函数（created,mounted）&lt;br&gt;父→子（自定义属性）；子→父（自定义事件）；兄弟组件（EventBus）&lt;br&gt;使用 ref 引用 DOM 元素或组件</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>重点知识：</strong> </p><blockquote><p>vue中常用的生命周期函数（created,mounted）<br>父→子（自定义属性）；子→父（自定义事件）；兄弟组件（EventBus）<br>使用 ref 引用 DOM 元素或组件</p></blockquote><h2 id="1-侦听器"><a href="#1-侦听器" class="headerlink" title="1 侦听器"></a>1 侦听器</h2><h3 id="1-1-watch-侦听器"><a href="#1-1-watch-侦听器" class="headerlink" title="1.1 watch 侦听器"></a>1.1 watch 侦听器</h3><ol><li>什么是watch 侦听器<br>watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。语法格式如下：</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">count vm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">username</span><span class="token operator">:</span><span class="token string">''</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">watch</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token comment">//监听 uaername 值的变化</span>    <span class="token comment">//newVal 是"变化后的新值"，oldVal 是"变化之后的旧值"</span>    <span class="token function">username</span> <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span>oldVal</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span>oldVal<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>使用watch 检测用户名是否可用<br>监听 username 值的变化，并使用 axios 发起 Ajax 请求，检测当前输入的用户名是否可用：</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 监听 username 值的变化</span>  <span class="token keyword">async</span> <span class="token function">username</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token comment">// 使用 axios 发起请求，判断用户名是否可用</span>    <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">data</span><span class="token operator">:</span> res <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'https://www.escook.cn/api/finduser/'</span> <span class="token operator">+</span> newVal<span class="token punctuation">)</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>immeddiate 选项<br>默认情况下，组件在初次加载完毕后不会调用 watch 侦听器。如果想让 watch 侦听器立即被调用，则需要使用immediate 选项。示例代码如下：</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// handler 是固定写法，表示当 username 的值变化时，自动调用 handler 处理函数</span>    <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword">return</span>      <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">data</span><span class="token operator">:</span> res <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'https://www.escook.cn/api/finduser/'</span> <span class="token operator">+</span> newVal<span class="token punctuation">)</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">// 表示页面初次渲染好之后，就立即触发当前的 watch 侦听器</span>    <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>deep选项<br>如果 watch 侦听的是一个对象，如果对象中的属性值发生了变化，则无法被监听到。此时需要使用 deep 选项，代码示例如下：</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">count vm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">info</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">usernaem</span><span class="token operator">:</span><span class="token string">'admin'</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">watch</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">info</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>      <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span>oldVal<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token literal-property property">deep</span><span class="token operator">:</span>ture    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>监听对象单个属性的变化</li></ol><p>如果只想监听对象中单个属性的变化，则可以按照如下的方式定义 watch 侦听器：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">count vm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">info</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">usernaem</span><span class="token operator">:</span><span class="token string">'admin'</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">watch</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token string-property property">'info.username'</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>      <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-侦听器的格式"><a href="#1-2-侦听器的格式" class="headerlink" title="1.2 侦听器的格式"></a>1.2 侦听器的格式</h3><p>1.方法格式的侦听器</p><ul><li>缺点1：无法在刚进入页面的时候，自动触发！！！</li><li>缺点2：如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发侦听器！！！</li></ul><p>2.对象格式的侦听器</p><ul><li>好处1：可以通过 <strong>immediate</strong> 选项，让侦听器自动触发！！！</li><li>好处2：可以通过 <strong>deep</strong> 选项，让侦听器深度监听对象中每个属性的变化！！！</li></ul><blockquote><p>计算属性与侦听器的区别：计算属性侧重于监听多个值的变化，最终计算并返回一个新值;<br>侦听器侧重于监听单个数据的变化，最终执行特定的业务处理，不需要有任何返回值；</p></blockquote><h2 id="2-计算属性"><a href="#2-计算属性" class="headerlink" title="2. 计算属性"></a>2. 计算属性</h2><ol><li>什么是计算属性<br>计算属性指的是通过一系列运算之后，最终得到一个属性值。这个动态计算出来的属性值可以被模板结构或 methods 方法使用。示例代码如下</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 创建 Vue 实例，得到 ViewModel</span>  <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 红色</span>      <span class="token literal-property property">r</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token comment">// 绿色</span>      <span class="token literal-property property">g</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token comment">// 蓝色</span>      <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 点击按钮，在终端显示最新的颜色</span>      <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">rgb(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>r<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>g<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>计算属性的特点</li></ol><ul><li>虽然计算属性在声明的时候被定义为方法，但是计算属性的本质是一个属性</li><li>计算属性会缓存计算的结果，只有计算属性依赖的数据变化时，才会重新进行运算</li></ul><p>特点：<br>1.定义的时候，要被定义为“方法”<br>2.在使用计算属性的时候，当普通的属性使用即可</p><p>好处：<br>1.实现了代码的复用<br>2.只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值！</p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><blockquote><p>axios 是一个专注于网络请求的库！</p></blockquote><h3 id="axios-的基本使用"><a href="#axios-的基本使用" class="headerlink" title="axios 的基本使用"></a>axios 的基本使用</h3><ol><li>发起 GET 请求：</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 请求方式</span>  <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>  <span class="token comment">// 请求的地址</span>  <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://www.liulongbin.top:3006/api/getbooks'</span><span class="token punctuation">,</span>  <span class="token comment">// URL 中的查询参数</span>  <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>发起 POST 请求：</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#btnPost'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await！</span>  <span class="token comment">// await 只能用在被 async “修饰”的方法中</span>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">data</span><span class="token operator">:</span> res <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>     <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://www.liulongbin.top:3006/api/post'</span><span class="token punctuation">,</span>    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'zs'</span><span class="token punctuation">,</span>      <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">20</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>单页面应用程序</strong>（英文名：Single Page Application）简称 SPA，顾名<br>思义，指的是一个 Web 网站中只有唯一的一个 HTML 页面，所有的功能<br>与交互都在这唯一的一个页面内完成。</p></blockquote><h2 id="3-vue-cli"><a href="#3-vue-cli" class="headerlink" title="3. vue.cli"></a>3. vue.cli</h2><ol><li>什么是 vue.cli<br>vue-cli 是 Vue.js 开发的标准工具。它简化了程序员基于 webpack 创建工程化的 Vue 项目的过程。<blockquote><p>中文官网 <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p></blockquote></li><li>安装和使用<br>vue-cli 是 npm 上的一个全局包，使用 npm install 命令，即可方便的把它安装到自己的电脑上</li></ol><pre class="line-numbers language-none"><code class="language-none">npm install -g @vue&#x2F;cli   &#x2F;&#x2F;-g 表示全局包<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基于 vue-cli 快速生成工程化的 Vue 项目：</p><pre class="line-numbers language-none"><code class="language-none">vue create 项目的名称vue 项目中 src 目录的构成：  assets 文件夹：存放项目中用到的静态资源文件，例如：css 样式表、图片资源  components 文件夹：程序员封装的、可复用的组件，都要放到 components 目录下  main.js 是项目的入口文件。整个项目的运行，要先执行 main.js  App.vue 是项目的根组件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>vue项目的运行流程<br>在工程化的项目中，vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中。其中：<br>① App.vue 用来编写待渲染的模板结构<br>② index.html 中需要预留一个 el 区域<br>③ main.js 把 App.vue 渲染到了 index.html 所预留的区域中</li></ol><h2 id="4-vue-组件"><a href="#4-vue-组件" class="headerlink" title="4. vue 组件"></a>4. vue 组件</h2><h3 id="4-1-什么是组件化开发"><a href="#4-1-什么是组件化开发" class="headerlink" title="4.1 什么是组件化开发"></a>4.1 什么是组件化开发</h3><p>组件化开发指的是：根据封装的思想，把页面上可重用的 UI 结构封装为组件，从而方便项目的开发和维护。</p><h3 id="4-2-vue-中的组件化开发"><a href="#4-2-vue-中的组件化开发" class="headerlink" title="4.2 vue 中的组件化开发"></a>4.2 vue 中的组件化开发</h3><ul><li>vue 是一个支持组件化开发的前端框架。</li><li>vue 中规定：组件的后缀名是 .vue。之前接触到的 App.vue 文件本质上就是一个 vue 的组件</li></ul><h3 id="4-3-vue-组件的三个组成部分"><a href="#4-3-vue-组件的三个组成部分" class="headerlink" title="4.3 vue 组件的三个组成部分"></a>4.3 vue 组件的三个组成部分</h3><p>每个 .vue 组件都由 3 部分构成，分别是：</p><ul><li>template -&gt; 组件的模板结构</li><li>script -&gt; 组件的 JavaScript 行为</li><li>style -&gt; 组件的样式<br>其中，每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分。</li></ul><ol><li>template<br>vue 规定：每个组件对应的模板结构，需要定义到 <code>&lt;template&gt; </code>节点中。</li></ol><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>//DOM结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li>template 是 vue 提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的 DOM 元素</li><li>template 中只能包含唯一的根节点</li></ul><ol start="2"><li>script<br>vue 规定：开发者可以在<code>&lt;script&gt;</code>节点中封装组件的 JavaScript 业务逻辑。<code>&lt;script &gt;</code> 节点的基本结构如下</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token comment">//今后组件相关的 data 数据，methods 方法</span>  <span class="token comment">//都需要定义到 export default 所导出的对象中</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span>script<span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>vue 规定：.vue 组件中的 data 必须是一个函数，不能直接指向一个数据对象。会导致多个组件实例共用同一份数据的问题</p></blockquote><ol start="3"><li>style<br>vue 规定：组件内的 <code>&lt;style&gt;</code> 节点是可选的，开发者可以在 <code>&lt;style&gt;</code> 节点中编写样式美化当前组件的 UI 结构。<code>&lt;script &gt;</code> 节点的基本结构如下：</li></ol><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">&lt;style>  h1</span> <span class="token punctuation">&#123;</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>&lt;/style><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在 <code>&lt;style&gt;</code> 标签上添加 lang&#x3D;”less” 属性，即可使用 less 语法编写组件的样式</p></blockquote><h3 id="4-4-组件之间的关系（父子，兄弟）"><a href="#4-4-组件之间的关系（父子，兄弟）" class="headerlink" title="4.4 组件之间的关系（父子，兄弟）"></a>4.4 组件之间的关系（父子，兄弟）</h3><ol><li>使用组件的三个步骤</li></ol><p>—步骤1：使用 import 语法导入需要的组件<br>—步骤2：使用 components 节点注册组件<br>—步骤3：以标签形式使用刚才注册的组件</p><ol start="2"><li>通过 components 注册的是私有子组件</li></ol><p>—在组件 A 的 components 节点下，注册了组件 F。则组件 F 只能用在组件 A 中；不能被用在组件 C 中<br>3. 注册全局组件<br>vue 项目的 main.js 入口文件中，通过 Vue.component() 方法，可以注册全局组件。示例代码如下</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//导入需要全局注册的组件</span><span class="token keyword">import</span> Count <span class="token keyword">from</span> <span class="token string">'@/components/Count.vue'</span><span class="token comment">// 参数1： 字符串格式，表示组件的"注册名称"</span><span class="token comment">// 参数2： 需要被全局注册的那个组件</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'MyCount'</span><span class="token punctuation">,</span>Count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-组件的props"><a href="#4-5-组件的props" class="headerlink" title="4.5 组件的props"></a>4.5 组件的props</h3><p>props 是组件的自定义属性，在封装通用组件的时候，合理地使用 props 可以极大的提高<strong>组件的复用性</strong>！它的语法格式如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">[</span>自定义属性<span class="token constant">A</span><span class="token punctuation">,</span>自定义属性<span class="token constant">B</span>，自定义属性<span class="token operator">...</span><span class="token punctuation">]</span>  <span class="token comment">//组件的私有数据</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>props 是只读的<br> vue 规定：组件中封装的自定义属性是只读的，程序员不能直接修改 props 的值。否则会直接报错<br> 要想修改 props 的值，可以把 props 的值转存到 data 中，因为 data 中的数据都是可读可写的！</li><li>props 的default 默认值<br> 在声明自定义属性时，可以通过 default 来定义属性的默认值。示例代码如下<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  props ：<span class="token punctuation">&#123;</span>    <span class="token literal-property property">init</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>      <span class="token comment">//用default定义属性的默认值</span>      <span class="token keyword">default</span><span class="token operator">:</span><span class="token number">0</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>props 的type 值类型<br> 在声明自定义属性时，可以通过 type 来定义属性的值类型。示例代码如下<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  props ：<span class="token punctuation">&#123;</span>    <span class="token literal-property property">init</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>      <span class="token comment">//用default定义属性的默认值</span>      <span class="token keyword">default</span><span class="token operator">:</span><span class="token number">0</span>      <span class="token comment">//用 type 属性定义属性值的类型</span>      <span class="token comment">// 如果传递过来的值不符合此类型，则会在终端报错</span>      <span class="token literal-property property">type</span> <span class="token operator">:</span> Number    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>props 的 required 必填项<br> 在声明自定义属性时，可以通过 required 选项，将属性设置为必填项，强制用户必须传递属性的值。示例代<br> 码如下：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  props ：<span class="token punctuation">&#123;</span>    <span class="token literal-property property">init</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>      <span class="token literal-property property">type</span> <span class="token operator">:</span> Number      <span class="token literal-property property">required</span> <span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-组件之间的样式冲突问题"><a href="#4-6-组件之间的样式冲突问题" class="headerlink" title="4.6 组件之间的样式冲突问题"></a>4.6 组件之间的样式冲突问题</h3>默认情况下，写在 .vue 组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。<br>导致组件之间样式冲突的根本原因是：<br>① 单页面应用程序中，所有组件的 DOM 结构，都是基于唯一的 index.html 页面进行呈现的<br>② 每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素</li><li>style 节点的 scoped 属性<br> 为了提高开发效率和开发体验，vue 为 style 节点提供了 scoped 属性，从而防止组件之间的样式冲突问题：</li><li>&#x2F;deep&#x2F; 样式穿透<br>如果给当前组件的 style 节点添加了 scoped 属性，则当前组件的样式对其子组件是不生效的。如果想让某些样式对子组件生效，可以使用 &#x2F;deep&#x2F; 深度选择器；  **&#x2F;deep&#x2F;是vue2.x中使用的，在vue3.x中推荐使用 :deep() 替代 &#x2F;deep&#x2F;  **</li></ol><h2 id="5-组件的生命周期"><a href="#5-组件的生命周期" class="headerlink" title="5. 组件的生命周期"></a>5. 组件的生命周期</h2><p>生命周期（Life Cycle）是指一个组件从创建 -&gt; 运行 -&gt; 销毁的整个阶段，强调的是一个时间段。<br>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。</p><ol><li>当组件在内存中被<strong>创建完毕</strong>之后，会自动调用 <strong>created</strong> 函数</li><li>当组件被<strong>成功的渲染</strong>到页面上之后，会自动调用 <strong>mounted</strong> 函数</li><li>当组件在页面中被<strong>重新渲染完毕</strong>后，运行阶段可以调用 <strong>updated</strong> 函数</li><li>当组件被<strong>销毁完毕</strong>之后，会自动调用 <strong>unmounted</strong> 函数</li></ol><blockquote><p>注意：生命周期强调的是时间段，生命周期函数强调的是时间点。<br><strong>组件生命周期函数的分类</strong><br>第一阶段：<strong>组件创建阶段：</strong> new Vue() → beforeCreate → created （唯一1次：发Ajax请求初始数据）→ beforeMount → mounted（唯一1次：操作DOM元素）<br>第二阶段：<strong>组件运行阶段：</strong> beforeUpdate → updated （可以执行 0或多次）<br>第三阶段：<strong>组件销毁阶段：</strong> beforeUnmount → unmounted (唯一1次)</p></blockquote><h2 id="6-组件之间的数据共享"><a href="#6-组件之间的数据共享" class="headerlink" title="6. 组件之间的数据共享"></a>6. 组件之间的数据共享</h2><h3 id="6-1-组件之间的关系"><a href="#6-1-组件之间的关系" class="headerlink" title="6.1 组件之间的关系"></a>6.1 组件之间的关系</h3><p>在项目开发中，组件之间的最常见的关系分为如下两种：<br>① 父子关系<br>② 兄弟关系</p><h3 id="6-2-父子组件之间的数据共享"><a href="#6-2-父子组件之间的数据共享" class="headerlink" title="6.2 父子组件之间的数据共享"></a>6.2 父子组件之间的数据共享</h3><ol><li>父组件向子组件共享数据：<strong>自定义属性</strong></li><li>子组件向父组件共享数据：<strong>自定义事件</strong><h3 id="6-3-兄弟组件之间的数据共享"><a href="#6-3-兄弟组件之间的数据共享" class="headerlink" title="6.3 兄弟组件之间的数据共享"></a>6.3 兄弟组件之间的数据共享</h3> vue2.x 中，兄弟组件之间数据共享的方案是 EventBus！！！<br>EventBus 的使用步骤：<br>① 创建 eventBus.js 模块，并向外共享一个 Vue 的实例对象<br>② 在数据发送方，调用 bus.$emit(‘事件名称’, 要发送的数据) 方法触发自定义事件<br>③ 在数据接收方，调用 bus.$on(‘事件名称’, 事件处理函数) 方法注册一个自定义事件</li></ol><h2 id="7-ref-引用"><a href="#7-ref-引用" class="headerlink" title="7. ref 引用"></a>7. ref 引用</h2><h3 id="7-1-ref-引用的概念"><a href="#7-1-ref-引用的概念" class="headerlink" title="7.1 ref 引用的概念"></a>7.1 ref 引用的概念</h3><p>ref 用来辅助开发者在不依赖于 jQuery 的情况下，获取 DOM 元素或组件的引用。<br>每个 vue 的组件实例上，都包含一个 $refs 对象，里面存储着对应的 DOM 元素或组件的引用。默认情况下，<br>组件的 <code>$refs</code> 指向一个空对象。</p><h3 id="7-2-使用-ref-引用DOM-元素"><a href="#7-2-使用-ref-引用DOM-元素" class="headerlink" title="7.2 使用 ref 引用DOM 元素"></a>7.2 使用 ref 引用DOM 元素</h3><p>如果想要使用 ref 引用页面上的 DOM 元素，则可以按照如下的方式进行操作</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//使用 ref 属性，为对应的DOM 添加引用名称</span><span class="token operator">&lt;</span>h3 ref<span class="token operator">=</span><span class="token string">"myh3"</span><span class="token operator">></span>MyRef 组件 <span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span><span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"getRef"</span><span class="token operator">></span>获取 $refs 引用<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>  <span class="token function">getRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//通过 this.$refs.引用的名称  可以获取到 DOM 元素的引用</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>myh3<span class="token punctuation">)</span>    <span class="token comment">//操作 DOM 元素，把文本颜色改为红色</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>myh3<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color<span class="token operator">=</span><span class="token string">'red'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-使用-ref-引用组件实例"><a href="#7-3-使用-ref-引用组件实例" class="headerlink" title="7.3 使用 ref 引用组件实例"></a>7.3 使用 ref 引用组件实例</h3><p>如果想要使用 ref 引用页面上的组件实例，则可以按照如下的方式进行操作</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//使用 ref 属性，为对应的组件添加引用名称</span><span class="token operator">&lt;</span>my<span class="token operator">-</span>counter ref<span class="token operator">=</span><span class="token string">"counterRef"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>my<span class="token operator">-</span>counter<span class="token operator">></span><span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"getRef"</span><span class="token operator">></span>获取 $refs 引用<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>  <span class="token function">getRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//通过 this.$refs.引用的名称 可以引用组件的实例</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>counterRef<span class="token punctuation">)</span>    <span class="token comment">//引用到组件的实例后， 就可以调用组件上的methods方法</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>counterRef<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-4-控制文本框和按钮的按需切换"><a href="#7-4-控制文本框和按钮的按需切换" class="headerlink" title="7.4 控制文本框和按钮的按需切换"></a>7.4 控制文本框和按钮的按需切换</h3><p>通过布尔值 inputVisible 来控制组件中的文本框与按钮的按需切换。示例代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"inputvisible"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>button v<span class="token operator">-</span><span class="token keyword">else</span> @click<span class="token operator">=</span><span class="token string">"showInput"</span><span class="token operator">></span>展示input输入框<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//控制文本框和按钮的按需切换inputVisible: false,</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">methods</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">showInput</span><span class="token punctuation">(</span> <span class="token punctuation">&#123;</span> <span class="token comment">//切换布尔值，显示文本框</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>inputVisible <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-5-让文本框自动获得焦点"><a href="#7-5-让文本框自动获得焦点" class="headerlink" title="7.5 让文本框自动获得焦点"></a>7.5 让文本框自动获得焦点</h3><blockquote><p>当文本框展示出来之后，如果希望它立即获得焦点，则可以为其添加 ref 引用，并调用原生 DOM 对象的<br>.focus() 方法即可。</p></blockquote><h3 id="7-6-this-nextTick-cb-方法"><a href="#7-6-this-nextTick-cb-方法" class="headerlink" title="7.6  this.$nextTick(cb) 方法"></a>7.6  this.$nextTick(cb) 方法</h3><p>组件的 $nextTick(cb) 方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行。通俗的理解是：等组件的<br>DOM 更新完成之后，再执行 cb 回调函数。从而能保证 cb 回调函数可以操作到最新的 DOM 元素。</p>]]></content:encoded>
      
      
      <category domain="http://zhezhe0723.github.io/categories/Vue%E7%9A%84%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Vue的相关基础知识</category>
      
      
      <category domain="http://zhezhe0723.github.io/tags/Vue/">Vue</category>
      
      
      <comments>http://zhezhe0723.github.io/2022/04/05/vue-ji-chu-ru-men-er/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Vue基础入门</title>
      <link>http://zhezhe0723.github.io/2022/04/01/vue-ji-chu-ru-men/</link>
      <guid>http://zhezhe0723.github.io/2022/04/01/vue-ji-chu-ru-men/</guid>
      <pubDate>Fri, 01 Apr 2022 12:26:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;什么是vue&quot;&gt;&lt;a href=&quot;#什么是vue&quot; class=&quot;headerlink&quot; title=&quot;什么是vue&quot;&gt;&lt;/a&gt;什么是vue&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;构建用户界面&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;用vue往HTML页面中填充数据，非常方便&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;框架&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;框架是一套现成的解决方案，程序员只能遵守框架内的规范，去编写自己的业务功能！&lt;/li&gt;
&lt;li&gt;要学习vue，就是在学习vue框架中规定的用法！&lt;/li&gt;
&lt;li&gt;vue的指令，组件（是对UI结构的复用），路由，Vuex，vue组件库&lt;/li&gt;
&lt;li&gt;只有把上面罗列的知识，掌握之后，才有开发vue项目的能力&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是vue"><a href="#什么是vue" class="headerlink" title="什么是vue"></a>什么是vue</h2><ol><li>构建用户界面</li></ol><ul><li>用vue往HTML页面中填充数据，非常方便</li></ul><ol start="2"><li>框架</li></ol><ul><li>框架是一套现成的解决方案，程序员只能遵守框架内的规范，去编写自己的业务功能！</li><li>要学习vue，就是在学习vue框架中规定的用法！</li><li>vue的指令，组件（是对UI结构的复用），路由，Vuex，vue组件库</li><li>只有把上面罗列的知识，掌握之后，才有开发vue项目的能力</li></ul><span id="more"></span><p><strong>重点：</strong></p><ol><li>能够知道 vue 的基本使用步骤：①导入vue.js文件，②new Vue()构造函数，得到vm实例对象，③声明 el 和 data 数据节点，④ MVVM 的对应关系</li><li>掌握 vue 中常见指令的基本用法：插值表达式，v-bind(:),v-on(@),v-if和v-else;v-for,:key,v-model</li></ol><h2 id="vue-的特性"><a href="#vue-的特性" class="headerlink" title="vue 的特性"></a>vue 的特性</h2><p>1.数据驱动视图</p><ul><li>数据的变化<strong>会驱动视图</strong>自动更新</li><li>好处：程序员只管把数据维护好，那么页面结构会被vue自动渲染出来!</li></ul><p>2.双向数据绑定</p><blockquote><p>在网页中，form表单负责<strong>采集数据</strong>，Ajax负责<strong>提交数据</strong>！</p></blockquote><ul><li>js数据的变化，会被自动渲染到页面上，开发者不需要手动操作DOM元素</li><li>页面上表单采集的数据发生变化的时候，会被vue自动获取到，并更新到js数据中<blockquote><p>注意：数据驱动视图和双向数据绑定的底层原理是 MVVM（Mode 数据源、View 视图、ViewModel 就是 vue 的实例）</p></blockquote></li></ul><h2 id="vue的使用"><a href="#vue的使用" class="headerlink" title="vue的使用"></a>vue的使用</h2><ol><li>导入vue.js的script脚本文件</li><li>在页面中声明一个将要被vue所控制的DOM区域</li><li>创建vm 实例对象（vue实例对象）</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 希望Vue能够控制下面的这个div 帮我们在把数据填充到div 内部 --&gt;&lt;div id&#x3D;&quot;app&quot;&gt;&#123;&#123; username &#125;&#125;&lt;&#x2F;div&gt;&lt;!-- 1.导入Vue的库文件，在Windows全局就有了Vue构造函数 --&gt;&lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;vue-2.6.12.js&quot;&gt;&lt;&#x2F;script&gt;&lt;!-- 2.创建Vue实例对象 --&gt;&lt;script&gt;    &#x2F;&#x2F; 创建Vue的实例对象    const vm &#x3D; new Vue(&#123;        &#x2F;&#x2F; el 属性是固定写法，表示当前vm实例要控制页面上的哪个区域，接收的值是一个选择器        el: &#39;#app&#39;,        &#x2F;&#x2F; data 对象就是要渲染到页面上的数据        data: &#123;            username: &#39;zhangsan&#39;        &#125;    &#125;)&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vue-的调试工具"><a href="#vue-的调试工具" class="headerlink" title="vue 的调试工具"></a>vue 的调试工具</h2><ol><li>安装vue-devtools调试工具：vue官方提供的vue-devtools调试工具，能够方便对开发者对vue项目进行调试与开发<blockquote><p>Chrome浏览器在线安装 <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd">vue-devtools</a></p></blockquote></li></ol><h2 id="vue-的指令"><a href="#vue-的指令" class="headerlink" title="vue 的指令"></a>vue 的指令</h2><h3 id="内容渲染指令"><a href="#内容渲染指令" class="headerlink" title="内容渲染指令"></a>内容渲染指令</h3><ol><li><code>v-text</code> ：<code>&lt;p v-text=&quot;gender&quot;&gt;性别&lt;/p&gt;</code>指令的缺点：会覆盖元素内部原有的内容！</li><li><code>&#123;&#123; &#125;&#125;</code> 插值表达式：在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容！</li><li><code>v-html</code> 指令的作用：可以把带有标签的字符串，渲染成真正的 HTML 内容！<blockquote><p> 注意：插值表达式只能用在元素的<strong>内容节点</strong>中，不能用在元素的<strong>属性节点</strong>中！</p></blockquote><h3 id="属性绑定指令"><a href="#属性绑定指令" class="headerlink" title="属性绑定指令"></a>属性绑定指令</h3></li></ol><ul><li>在 vue 中，可以使用 <code>v-bind:</code> 指令，为元素的属性动态绑定值；</li><li>简写是英文的 <code>:</code></li><li>在使用 v-bind 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如 <pre class="line-numbers language-none"><code class="language-none">&lt;div :title&#x3D;&quot;&#39;box&#39; + index&quot;&gt;这是一个 div&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="事件绑定指令"><a href="#事件绑定指令" class="headerlink" title="事件绑定指令"></a>事件绑定指令</h3></li></ul><ol><li><code>v-on</code>事件绑定指令，用来辅助程序员为DOM元素绑定事件监听，简写形式：<code>@</code></li><li>语法格式为：通过v-on绑定的事件处理函数，需要在<code>methods</code>节点中进行声明</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"add"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>   <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 如果在方法中要修改 data 中的数据，可以通过 this 访问到</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>   <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：原生 DOM 对象有 onclick、oninput、onkeyup 等原生事件，替换为 vue 的事件绑定形式后，<br>分别为：v-on:click、v-on:input、v-on:keyup</p></blockquote><p>3.<code>$event</code> 的应用场景：如果默认的事件对象 e 被覆盖了，则可以手动传递一个 $event。例如：</p><pre class="line-numbers language-none"><code class="language-none">&lt;button @click&#x3D;&quot;add(3, $event)&quot;&gt;&lt;&#x2F;button&gt;  methods: &#123;     add(n, e) &#123;  &#x2F;&#x2F; 如果在方法中要修改 data 中的数据，可以通过 this 访问到  this.count +&#x3D; 1     &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.事件修饰符：在事件处理函数中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。因此，vue 提供了事件修饰符的概念，来辅助程序员更方便的对事件的触发进行控制</p><ul><li><p><code>.prevent</code>：阻止默认行为</p>   <pre class="line-numbers language-none"><code class="language-none">&lt;a @click.prevent&#x3D;&quot;xxx&quot;&gt;链接&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>.stop</code> ：阻止事件冒泡</p>   <pre class="line-numbers language-none"><code class="language-none">&lt;button @click.stop&#x3D;&quot;xxx&quot;&gt;按钮&lt;&#x2F;button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>5.案件修饰符：在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符，</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;只有在 key 是  Enter 时调用  vm.submit() &lt;input @keyup.enter&#x3D;&quot;submit&quot;&gt;&#x2F;&#x2F;只有在 key 是  Esc 时调用  vm.clearInput() &lt;input @keyup.esc&#x3D;&quot;clearInput&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双向绑定指令"><a href="#双向绑定指令" class="headerlink" title="双向绑定指令"></a>双向绑定指令</h3><p>vue 提供了 <code>v-model</code> 双向数据绑定指令，用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据。</p><ol><li>input 输入框<ul><li>type&#x3D;”radio”</li><li>type&#x3D;”checkbox”</li><li>type&#x3D;”xxxx”</li></ul></li><li>textarea</li><li>select</li><li>v-model 指令的修饰符<ul><li>.number:自动将用户的输入值转为数值类型 <code>&lt;input v-model.number=&quot;age&quot;/&gt;</code></li></ul><ul><li>.trim: 自动过滤用户输入的首尾空白字符  <code>&lt;inut v-model.trim=&quot;msg&quot;/&gt;</code></li><li>.lazy： 在”change”时而非”input”时更新 <code>&lt;input v-model.lazy=&quot;msg&quot;/&gt;</code></li></ul></li></ol><h3 id="条件渲染指令"><a href="#条件渲染指令" class="headerlink" title="条件渲染指令"></a>条件渲染指令</h3><p>条件渲染指令用来辅助开发者按需控制 DOM 的显示与隐藏。条件渲染指令有如下两个，分别是：</p><ul><li>v-if</li><li>v-show</li></ul><ol><li><code>v-show</code> 的原理是：动态为元素添加或移除 <code>display: none</code> 样式，来实现元素的显示和隐藏<ul><li>如果要频繁的切换元素的显示状态，用 v-show 性能会更好</li></ul></li><li><code>v-if</code> 的原理是：每次动态创建或移除元素，实现元素的显示和隐藏<ul><li>如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时 v-if 性能更好</li></ul></li></ol><blockquote><p> 在实际开发中，绝大多数情况，不用考虑性能问题，直接使用 v-if 就好了！！！</p></blockquote><ol start="3"><li><p><code>v-else</code> : v-if 可以单独使用，或配合 v-else 指令一起使用：v-else 指令必须配合 v-if 指令一起使用，否则它将不会被识别！</p><h3 id="列表渲染指令"><a href="#列表渲染指令" class="headerlink" title="列表渲染指令"></a>列表渲染指令</h3><p>vue 提供了 <code>v-for</code> 列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构。v-for 指令需要使<br>用 <code>item in items</code> 形式的特殊语法，其中：</p><ul><li>items 是待循环的数组</li><li>item 是被循环的每一项</li></ul></li></ol><ul><li>v-for 指令还支持一个可选的第二个参数，即当前项的索引。语法格式为 (item, index) in items，<blockquote><p>注意：v-for 指令中的 item 项和 index 索引都是形参，可以根据需要进行重命名。例如 (user, i) in userlist</p></blockquote></li></ul><p><strong>使用 key 维护列表的状态</strong>:<br>当列表的数据变化时，默认情况下，vue 会尽可能的复用已存在的 DOM 元素，从而提升渲染的性能。但这种默认的性能优化策略，会导致有状态的列表无法被正确更新。<br>为了给 vue 一个提示，以便它能跟踪每个节点的身份，从而在保证有状态的列表被正确更新的前提下，提升渲<br>染的性能。此时，需要为每项提供一个唯一的 key 属性：<br><strong>key 的注意事项</strong>:<br>① key 的值只能是字符串或数字类型<br>② key 的值必须具有唯一性（即：key 的值不能重复）<br>③ 建议把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性）<br>④ 使用 index 的值当作 key 的值没有任何意义（因为 index 的值不具有唯一性）<br>⑤ 建议使用 v-for 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱）</p><h2 id="Vue的过滤器"><a href="#Vue的过滤器" class="headerlink" title="Vue的过滤器"></a>Vue的过滤器</h2><h3 id="定义过滤器"><a href="#定义过滤器" class="headerlink" title="定义过滤器"></a>定义过滤器</h3><p>  在创建vue 实例期间，可以在 <code>filters</code> 节点中定义过滤器，</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">count vm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>     <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">'hello vue.js'</span><span class="token punctuation">,</span>     <span class="token literal-property property">info</span><span class="token operator">:</span> <span class="token string">'title info'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">filters</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//在filters 节点下定义"过滤器"</span>    <span class="token function">capitalize</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//把首字母转为大写的过滤器</span>       <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="私有过滤器和全局过滤器"><a href="#私有过滤器和全局过滤器" class="headerlink" title="私有过滤器和全局过滤器"></a>私有过滤器和全局过滤器</h3><p>在 filters 节点下定义的过滤器，称为“私有过滤器”，因为它只能在当前 vm 实例所控制的 el 区域内使用。<br>如果希望在多个 vue 实例之间共享过滤器，则可以按照如下的格式定义全局过滤器：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">  <span class="token comment">//全局过滤器--独立于每个 vm 实例之外</span>  <span class="token comment">//Vue.filters() 方法，接收两个参数</span>  <span class="token comment">//第一个参数，是全局过滤器的 "名字"</span>  <span class="token comment">//第二个参数，是全局过滤器的 "处理函数"</span>Vue<span class="token punctuation">.</span><span class="token function">filters</span><span class="token punctuation">(</span><span class="token string">'capitalize'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token operator">=></span><span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'~~'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="过滤器的调用"><a href="#过滤器的调用" class="headerlink" title="过滤器的调用"></a>过滤器的调用</h3><p>过滤器可以串联的进行调用 <code>&#123;&#123;message | filterA | filterB&#125;&#125;</code>  中间用 ‘|’ 隔开<br>A–处理过的值传递给 B ，最终把 B处理的结果渲染到页面上</p><h3 id="过滤器传参"><a href="#过滤器传参" class="headerlink" title="过滤器传参"></a>过滤器传参</h3><p>  过滤器的本质是JavaScript 函数，因此可以接收参数，</p><pre class="line-numbers language-none"><code class="language-none">  &lt;p&gt;&#123;&#123;message | filterA(arg1,arg2) &#125;&#125;&lt;&#x2F;p&gt;   Vue.filter(&#39;filterA&#39;,(msg,arg1,arg2)&#x3D;&gt;&#123;   &#x2F;&#x2F;过滤器代码逻辑&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="过滤器的兼容性"><a href="#过滤器的兼容性" class="headerlink" title="过滤器的兼容性"></a>过滤器的兼容性</h3><p>过滤器仅在 vue 2.x 和 1.x 中受支持，在 vue 3.x 的版本中剔除了过滤器相关的功能。<br>在企业级项目开发中：</p><ul><li>如果使用的是 2.x 版本的 vue，则依然可以使用过滤器相关的功能</li><li>如果项目已经升级到了 3.x 版本的 vue，官方建议使用计算属性或方法代替被剔除的过滤器功能<br>具体的迁移指南，请参考 vue 3.x 的官方文档给出的说明：<a href="https://v3.vuejs.org/guide/migration/filters.html#migration-strategy">https://v3.vuejs.org/guide/migration/filters.html#migration-strategy</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://zhezhe0723.github.io/categories/Vue%E7%9A%84%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Vue的相关基础知识</category>
      
      
      <category domain="http://zhezhe0723.github.io/tags/Vue/">Vue</category>
      
      
      <comments>http://zhezhe0723.github.io/2022/04/01/vue-ji-chu-ru-men/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Express</title>
      <link>http://zhezhe0723.github.io/2022/03/16/express/</link>
      <guid>http://zhezhe0723.github.io/2022/03/16/express/</guid>
      <pubDate>Wed, 16 Mar 2022 13:17:57 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Express简介&quot;&gt;&lt;a href=&quot;#Express简介&quot; class=&quot;headerlink&quot; title=&quot;Express简介&quot;&gt;&lt;/a&gt;Express简介&lt;/h2&gt;&lt;h3 id=&quot;什么是Express&quot;&gt;&lt;a href=&quot;#什么是Express&quot; class=&quot;headerlink&quot; title=&quot;什么是Express&quot;&gt;&lt;/a&gt;什么是Express&lt;/h3&gt;&lt;p&gt;官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。&lt;br&gt;通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。&lt;br&gt;Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。&lt;br&gt;Express 的中文官网：&lt;a href=&quot;http://www.expressjs.com.cn/&quot;&gt;http://www.expressjs.com.cn/&lt;/a&gt; &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Express简介"><a href="#Express简介" class="headerlink" title="Express简介"></a>Express简介</h2><h3 id="什么是Express"><a href="#什么是Express" class="headerlink" title="什么是Express"></a>什么是Express</h3><p>官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。<br>通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。<br>Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。<br>Express 的中文官网：<a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a> </p><span id="more"></span><h3 id="Express的作用"><a href="#Express的作用" class="headerlink" title="Express的作用"></a>Express的作用</h3><p>对于前端程序员来说，最常见的两种服务器，分别是：</p><ul><li>Web 网站服务器：专门对外提供 Web 网页资源的服务器。</li><li>API 接口服务器：专门对外提供 API 接口的服务器。<br>使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器</li></ul><h3 id="Express的基本使用"><a href="#Express的基本使用" class="headerlink" title="Express的基本使用"></a>Express的基本使用</h3><ul><li>安装Express<br>在项目所处的目录中，运行如下的终端命令，即可将 express 安装到项目中使用<pre class="line-numbers language-none"><code class="language-none">npm i express@4.17.1   &#x2F;&#x2F;express版本号可有可无，但是学习的时候必须和老师保持一致<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>创建基本的Web服务器<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;1．导入、express  const express &#x3D; require( &quot; express &quot;)&#x2F;&#x2F;2，创建web服字果 const app &#x3D; express()&#x2F;&#x2F;3．调用 app.listen(端口号，启动成功后的回调函数)，启动服务器 app.listen(8o,()&#x3D;&gt; &#123;   console.log( &#39;express server running at http:&#x2F;&#x2F;127.0.0.1&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>监听GET请求<br>通过 app.get() 方法，可以监听客户端的 GET 请求，具体的语法格式如下：<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;参数1:客户端请求的URL地址&#x2F;&#x2F;参数2:请求对应的处理函数req:请求对象(包含了与请求相关的属性与方法)res:响应对象(包含了与响应相关的属性与方法)app.get( &#39;请求URL&#39;, function(req,res) &#123;&#x2F;*处理函数*&#x2F;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>监听POST请求<br>通过 app.post() 方法，可以监听客户端的 POST 请求，具体的语法格式如下<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;参数1:客户端请求的URL地址&#x2F;&#x2F;参数2:请求对应的处理函数&#x2F;&#x2F;  req:请求对象（包含了与请求相关的属性与方法)&#x2F;&#x2F;  res:响应对象(包含了与响应相关的属性与方法)app.post( &#39;请求URL&#39; function(req,res) &#123;&#x2F;*处理函数*&#x2F;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>把内容响应给客户端<br>通过 res.send() 方法，可以把处理好的内容，发送给客户端：<pre class="line-numbers language-none"><code class="language-none">app.get(&#39;&#x2F;user&#39;, (req, res) &#x3D;&gt; &#123;  &#x2F;&#x2F; 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象res.send(&#123; name: &#39;zs&#39;, age: 20, gender: &#39;男&#39; &#125;)&#125;)app.post(&#39;&#x2F;user&#39;, (req, res) &#x3D;&gt; &#123;  &#x2F;&#x2F; 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串 res.send(&#39;请求成功&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>获取URL中携带的查询参数<br>通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：<pre class="line-numbers language-none"><code class="language-none"> app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;&#x2F;&#x2F; 通过 req.query 可以获取到客户端发送过来的 查询参数&#x2F;&#x2F; 注意：默认情况下，req.query 是一个空对象console.log(req.query)res.send(req.query)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>获取URL中的动态参数<br>通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数：<pre class="line-numbers language-none"><code class="language-none"> &#x2F;&#x2F; 注意：这里的 :id 是一个动态的参数app.get(&#39;&#x2F;user&#x2F;:ids&#x2F;:username&#39;, (req, res) &#x3D;&gt; &#123;&#x2F;&#x2F; req.params 是动态匹配到的 URL 参数，默认也是一个空对象console.log(req.params)res.send(req.params)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3>express 提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：<pre class="line-numbers language-none"><code class="language-none">app.use(express.static(&#39;public&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>现在，你就可以访问 public 目录中的所有文件了：<br><a href="http://localhost:3000/images/bg.jpg">http://localhost:3000/images/bg.jpg</a><br><a href="http://localhost:3000/css/style.css">http://localhost:3000/css/style.css</a><br><a href="http://localhost:3000/js/login.js">http://localhost:3000/js/login.js</a></li></ul><p><strong>注意：</strong></p><ul><li>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在 URL 中</li><li>如果要托管多个静态资源目录，就要多次调用express.static()函数，但是函数会根据目录的添加顺序查找所需的文件</li></ul><p><strong>挂载路径前缀：</strong>如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：</p><pre class="line-numbers language-none"><code class="language-none">app.use(&#39;&#x2F;pubic&#39;,express.static(&#39;public&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，你就可以通过带有 &#x2F;public 前缀地址来访问 public 目录中的文件了：<br><a href="http://localhost:3000/public/images/kitten.jpg">http://localhost:3000/public/images/kitten.jpg</a><br><a href="http://localhost:3000/public/css/style.css">http://localhost:3000/public/css/style.css</a><br><a href="http://localhost:3000/public/js/app.js">http://localhost:3000/public/js/app.js</a></p><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。<br>现在，我们可以使用 nodemon <a href="https://www.npmjs.com/package/nodemon">https://www.npmjs.com/package/nodemon</a> 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。<br>**安装nodemon:**在终端中，运行如下命令，即可将 nodemon 安装为全局可用的工具：</p><pre class="line-numbers language-none"><code class="language-none">npm i -g nodemon  &#x2F;&#x2F;-g  全局<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 node app.js 命令，来启动项目。这样做的坏处是：代码被修改之后，需要手动重启项目。<br>现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。这样做的好处是：代码被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果。</p><h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a>Express 路由</h2><h3 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h3><p>广义上来讲，路由就是映射关系。在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。<br>Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数，格式如下：<br> <strong>app.METHOD(PATH,HANDLER)</strong><br><strong>路由的匹配过程：</strong><br>每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。<br>在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。</p><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><ul><li>最简单的用法<br>在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下：<pre class="line-numbers language-none"><code class="language-none">  const express &#x3D; require(&#39;express&#39;)  const app &#x3D; express()&#x2F;&#x2F; 挂载路由app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;  res.send(&#39;hello world.&#39;)&#125;)app.post(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123; res.send(&#39;Post Request.&#39;)&#125;)  &#x2F;&#x2F;启动Web服务器app.listen(80, () &#x3D;&gt; &#123; console.log(&#39;http:&#x2F;&#x2F;127.0.0.1&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>路由的模块化<br>为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。<br>将路由抽离为单独模块的步骤如下：</li></ul><p>1.创建路由模块对应的 .js 文件<br>2.调用 express.Router() 函数创建路由对象<br>3.向路由对象上挂载具体的路由<br>4.使用 module.exports 向外共享路由对象<br>5.使用 app.use() 函数注册路由模块</p><ul><li>创建路由模块<pre class="line-numbers language-none"><code class="language-none">   &#x2F;&#x2F; 这是路由模块   &#x2F;&#x2F; 1. 导入 express   const express &#x3D; require(&#39;express&#39;)   &#x2F;&#x2F; 2. 创建路由对象   const router &#x3D; express.Router()   &#x2F;&#x2F; 3. 挂载具体的路由   router.get(&#39;&#x2F;user&#x2F;list&#39;, (req, res) &#x3D;&gt; &#123;     res.send(&#39;Get user list.&#39;)   &#125;)   router.post(&#39;&#x2F;user&#x2F;add&#39;, (req, res) &#x3D;&gt; &#123;     res.send(&#39;Add new user.&#39;)   &#125;)&#x2F;&#x2F; 4. 向外导出路由对象module.exports &#x3D; router<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>注册路由模块<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 1. 导入路由模块   const router &#x3D; require(&#39;.&#x2F;03.router&#39;)&#x2F;&#x2F; 2. 注册路由模块   app.use(&#39;&#x2F;api&#39;, router)&#x2F;&#x2F; 注意： app.use() 函数的作用，就是来注册全局中间件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content:encoded>
      
      
      <category domain="http://zhezhe0723.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/">前后端交互</category>
      
      
      <category domain="http://zhezhe0723.github.io/tags/Express/">Express</category>
      
      
      <comments>http://zhezhe0723.github.io/2022/03/16/express/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>npm与包的简单概念</title>
      <link>http://zhezhe0723.github.io/2022/03/10/npm-yu-bao-de-jian-dan-gai-nian/</link>
      <guid>http://zhezhe0723.github.io/2022/03/10/npm-yu-bao-de-jian-dan-gai-nian/</guid>
      <pubDate>Thu, 10 Mar 2022 02:39:29 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;包&quot;&gt;&lt;a href=&quot;#包&quot; class=&quot;headerlink&quot; title=&quot;包&quot;&gt;&lt;/a&gt;包&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;包的概念：&lt;/strong&gt;Node.js 中的第三方模块又叫做包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包的来源：&lt;/strong&gt;不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。注意：Node.js 中的包都是免费且开源的，不需要付费即可免费下载使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为什么需要包：&lt;/strong&gt;由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低。&lt;br&gt;包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率。&lt;br&gt;包和内置模块之间的关系，类似于 jQuery 和 浏览器内置 API 之间的关系</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><ul><li><strong>包的概念：</strong>Node.js 中的第三方模块又叫做包。</li><li><strong>包的来源：</strong>不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。注意：Node.js 中的包都是免费且开源的，不需要付费即可免费下载使用。</li><li><strong>为什么需要包：</strong>由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低。<br>包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率。<br>包和内置模块之间的关系，类似于 jQuery 和 浏览器内置 API 之间的关系<span id="more"></span></li><li><strong>从哪里下载包：</strong>国外有一家 IT 公司，叫做 npm, Inc. 这家公司旗下有一个非常著名的网站： <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> ，它是全球最大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心！<br>到目前位置，全球约 1100 多万的开发人员，通过这个包共享平台，开发并共享了超过 120 多万个包 供我们使用。<br>npm, Inc. 公司提供了一个地址为 <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。</li></ul><p>注意：<br> 从 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 网站上搜索自己所需要的包<br> 从 <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>  服务器上下载自己需要的包</p><ul><li><strong>如何下载包：</strong>npm, Inc. 公司提供了一个包管理工具，我们可以使用这个包管理工具，从 <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器把需要的包下载到本地使用。<br>这个包管理工具的名字叫做 Node Package Manager（简称 npm 包管理工具），这个包管理工具随着 Node.js 的安装包一起被安装到了用户的电脑上。</li></ul><h1 id="npm-的使用"><a href="#npm-的使用" class="headerlink" title="npm 的使用"></a>npm 的使用</h1><ul><li>格式化时间的传统做法</li></ul><p>创建格式化时间的自定义模块<br>定义格式化时间的方法<br>创建补零函数<br>从自定义模块中导出格式化时间的函数<br>导入格式化时间的自定义模块<br>调用格式化时间的函数</p><ul><li>格式化时间的高级做法</li></ul><p>使用 npm 包管理工具，在项目中安装格式化时间的包 moment<br>使用 require() 导入格式化时间的包<br>参考 moment 的官方 API 文档对时间进行格式化</p><h2 id="在项目中安装包的命令"><a href="#在项目中安装包的命令" class="headerlink" title="在项目中安装包的命令"></a>在项目中安装包的命令</h2><p>如果想在项目中安装指定名称的包，需要运行如下的命令</p><pre class="line-numbers language-none"><code class="language-none">npm install 包的完整名称&#x2F;&#x2F;简写格式npm i 包的完整名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="初次装包后多了哪些文件"><a href="#初次装包后多了哪些文件" class="headerlink" title="初次装包后多了哪些文件"></a>初次装包后多了哪些文件</h2><p>初次装包完成后，在项目文件夹下多一个叫做 node_modules 的文件夹和 package-lock.json 的配置文件。<br>其中：</p><ul><li>node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。</li><li>package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。<br>注意：程序员不要手动修改 node_modules 或 package-lock.json 文件中的任何代码，npm 包管理工具会自动维护它们。<h2 id="安装指定版本的包"><a href="#安装指定版本的包" class="headerlink" title="安装指定版本的包"></a>安装指定版本的包</h2>默认情况下，使用 npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过 @ 符号指定具体的版本，<pre class="line-numbers language-none"><code class="language-none">npm i moment@2.22.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="包管理配置文件"><a href="#包管理配置文件" class="headerlink" title="包管理配置文件"></a>包管理配置文件</h1>npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置信息。例如：</li><li>项目的名称、版本号、描述等</li><li>项目中都用到了哪些包</li><li>哪些包只在开发期间会用到 </li><li>那些包在开发和部署时都需要用到</li></ul><h2 id="如何记录项目中安装了哪些包"><a href="#如何记录项目中安装了哪些包" class="headerlink" title="如何记录项目中安装了哪些包"></a>如何记录项目中安装了哪些包</h2><p>在项目根目录中，创建一个叫做 package.json 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码。</p><p>注意：今后在项目开发中，一定要把 node_modules 文件夹，添加到 .gitignore 忽略文件中。</p><h2 id="快速创建-package-json"><a href="#快速创建-package-json" class="headerlink" title="快速创建 package.json"></a>快速创建 package.json</h2><p>npm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理配置文件</p><pre class="line-numbers language-none"><code class="language-none">npm init -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意:</strong></p><ul><li>上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。</li><li>运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。</li></ul><h2 id="一次性安装所有的包"><a href="#一次性安装所有的包" class="headerlink" title="一次性安装所有的包"></a>一次性安装所有的包</h2><p>当我们拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来<br>可以运行 npm install 命令（或 npm i）一次性安装所有的依赖包</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;执行npm install 命令时，npm包管理工具会先读取package. json中的dependencies 节点，&#x2F;&#x2F;读取到记录的所有依赖包名称和版本号之后，npm包管理工具会把这些包次性下载到项目中npm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h2><p>可以运行 npm uninstall 命令，来卸载指定的包</p><pre class="line-numbers language-none"><code class="language-none">npm uninstall 包的完整名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><ol><li>dependencies 节点<br>package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包。</li><li>devDependencies 节点<br>如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。<br>您可以使用如下的命令，将包记录到 devDependencies 节点中<pre class="line-numbers language-none"><code class="language-none">npm install 包名 --save-dev   &#x2F;&#x2F;完整写法npm i 包名 -D     &#x2F;&#x2F;简写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="切换-npm-的下包镜像源"><a href="#切换-npm-的下包镜像源" class="headerlink" title="切换 npm 的下包镜像源"></a>切换 npm 的下包镜像源</h2>下包的镜像源，指的就是下包的服务器地址<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;查看当前的下包镜像源npm config get registry&#x2F;&#x2F;将下包的镜像源切换为淘宝镜像源npm config set registry&#x3D;https :&#x2F;&#x2F;registry .npm. taobao .org&#x2F;&#x2F;&#x2F;检查镜像源是否下载成功npm config get registry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h2>为了更方便的切换下包的镜像源，我们可以安装 nrm 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源。<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;通过npm包管理器，将nrm安装为全局可用的工具npm i nrm -g&#x2F;&#x2F;查看所有可用的镜像源nrm ls&#x2F;&#x2F;将下包的镜像源切换为taobao 镜像nrm use taobao<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="包的分类"><a href="#包的分类" class="headerlink" title="包的分类"></a>包的分类</h1>分为项目包和全局包<h2 id="项目包"><a href="#项目包" class="headerlink" title="项目包"></a>项目包</h2>那些被安装到项目的 node_modules 目录中的包，都是项目包。</li></ol><p>项目包又分为两类，分别是：</p><ul><li>开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）</li><li>核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）</li></ul><pre class="line-numbers language-none"><code class="language-none">npm i 包名 -D&#x2F;&#x2F;开发依赖包(会被记录到devDependencies 节点下)npm i包名&#x2F;&#x2F;核心依赖包(会被记录到dependencies 节点下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="全局包"><a href="#全局包" class="headerlink" title="全局包"></a>全局包</h2><p>在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。<br>全局包会被安装到 C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下。</p><pre class="line-numbers language-none"><code class="language-none">npm i 包名 -g    &#x2F;&#x2F;全局安装指定的包npm uninstall 包名 -g   &#x2F;&#x2F;卸载全局安装的包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：</p><ul><li>只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。</li><li>判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可</li></ul><h2 id="i5ting-toc"><a href="#i5ting-toc" class="headerlink" title="i5ting_toc"></a>i5ting_toc</h2><p>i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;将i5ting toc安装为全局包npm install -g i5ting_toc&#x2F;&#x2F;调用i5ting toc,轻松实现md转html的功能i5ting_toc -f 要转换的md文件路径 -o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="规范的包结构"><a href="#规范的包结构" class="headerlink" title="规范的包结构"></a>规范的包结构</h2><p>在清楚了包的概念、以及如何下载和使用包之后，接下来，我们深入了解一下包的内部结构。<br>一个规范的包，它的组成结构，必须符合以下 3 点要求：</p><ul><li>包必须以单独的目录而存在</li><li>包的顶级目录下要必须包含 package.json 这个包管理配置文件</li><li>package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。<br>注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：<br><a href="https://yarnpkg.com/zh-Hans/docs/package-json">https://yarnpkg.com/zh-Hans/docs/package-json</a></li></ul><h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><ol><li>注册npm 账号</li><li>登录npm 账号<br>npm 账号注册完成后，可以在终端中执行 npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功<br>注意：在运行 npm login 命令之前，必须先把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布包失败！</li><li>把包发布到npm上<br>将终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能雷同）</li><li>删除已发布的包</li></ol><p>运行 npm unpublish 包名 –force 命令，即可从 npm 删除已发布的包。注意：</p><ul><li>npm unpublish 命令只能删除 72 小时以内发布的包</li><li>npm unpublish 删除的包，在 24 小时内不允许重复发布</li><li>发布包的时候要慎重，尽量不要往 npm 上发布没有意义的包！</li></ul>]]></content:encoded>
      
      
      <category domain="http://zhezhe0723.github.io/categories/%E5%B7%A5%E5%85%B7/">工具</category>
      
      
      <category domain="http://zhezhe0723.github.io/tags/npm%E4%B8%8E%E5%8C%85/">npm与包</category>
      
      
      <comments>http://zhezhe0723.github.io/2022/03/10/npm-yu-bao-de-jian-dan-gai-nian/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
